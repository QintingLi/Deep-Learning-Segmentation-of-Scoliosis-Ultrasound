# -*- coding: utf-8 -*-
"""FCN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TAV25GgfrZIIar5MHkwaSosyu8a1Y5qq
"""

from google.colab import drive
drive.mount('/content/drive')

"""# **Loading and Preprocessing Image and Label Data**"""

import os
import numpy as np
from PIL import Image
from sklearn.model_selection import train_test_split
from scipy.ndimage import zoom
from PIL import ImageOps, ImageEnhance

def load_data(image_dir, label_dir, target_size):
    image_files = []
    label_files = []

    # Get the list of BMP format image files
    for file in os.listdir(image_dir):
        if file.endswith('.bmp'):
            image_files.append(os.path.join(image_dir, file))

    # Get the list of PNG format image files
    for file in os.listdir(label_dir):
        if file.endswith('.png'):
            label_files.append(os.path.join(label_dir, file))

    image_files = sorted(image_files)
    label_files = sorted(label_files)

    images = []
    labels = []

    # Load and preprocess image data
    for img_file, lbl_file in zip(image_files, label_files):
        img = Image.open(img_file).convert('RGB')
        lbl = Image.open(lbl_file).convert('L')

        # Resize images and labels to target size
        img = img.resize(target_size)
        lbl = lbl.resize(target_size)

        images.append(np.array(img, dtype=np.float32) / 255.0)  # Normalize image
        lbl = np.array(lbl)
        lbl = np.expand_dims(lbl, axis=-1)
        lbl[lbl > 0] = 1  # Binarize the label
        labels.append(lbl)

    images = np.array(images)
    labels = np.array(labels)

    return images, labels

# Define dataset paths and target size
image_dir = '/content/drive/MyDrive/image_10'
label_dir = '/content/drive/MyDrive/image_10_label'
target_size = (256, 256)  # Set the target size for images and labels

if os.path.isdir(image_dir) and os.path.isdir(label_dir):
    images, labels = load_data(image_dir, label_dir, target_size)

    # Split the dataset into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(images, labels, test_size=0.1, random_state=42)

    # Proceed with model training and other steps as needed
else:
    print("Please provide valid image and label directory paths.")

"""# **Building an FCN Model**"""

from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Conv2DTranspose, Add

def fcn_model(input_shape, num_classes):
    inputs = Input(shape=input_shape)

    # Encoder
    conv1 = Conv2D(64, (3, 3), activation='relu', padding='same')(inputs)
    conv1 = Conv2D(64, (3, 3), activation='relu', padding='same')(conv1)
    pool1 = MaxPooling2D((2, 2))(conv1)

    conv2 = Conv2D(128, (3, 3), activation='relu', padding='same')(pool1)
    conv2 = Conv2D(128, (3, 3), activation='relu', padding='same')(conv2)
    pool2 = MaxPooling2D((2, 2))(conv2)

    conv3 = Conv2D(256, (3, 3), activation='relu', padding='same')(pool2)
    conv3 = Conv2D(256, (3, 3), activation='relu', padding='same')(conv3)
    pool3 = MaxPooling2D((2, 2))(conv3)

    conv4 = Conv2D(512, (3, 3), activation='relu', padding='same')(pool3)
    conv4 = Conv2D(512, (3, 3), activation='relu', padding='same')(conv4)
    pool4 = MaxPooling2D((2, 2))(conv4)

    conv5 = Conv2D(512, (3, 3), activation='relu', padding='same')(pool4)
    conv5 = Conv2D(512, (3, 3), activation='relu', padding='same')(conv5)
    pool5 = MaxPooling2D((2, 2))(conv5)

    # Decoder with skip connections
    up6 = Conv2DTranspose(512, (3, 3), strides=(2, 2), activation='relu', padding='same')(pool5)
    up6 = Add()([up6, conv5])

    up7 = Conv2DTranspose(512, (3, 3), strides=(2, 2), activation='relu', padding='same')(up6)
    up7 = Add()([up7, conv4])

    up8 = Conv2DTranspose(256, (3, 3), strides=(2, 2), activation='relu', padding='same')(up7)
    up8 = Add()([up8, conv3])

    up9 = Conv2DTranspose(128, (3, 3), strides=(2, 2), activation='relu', padding='same')(up8)
    up9 = Add()([up9, conv2])

    up10 = Conv2DTranspose(64, (3, 3), strides=(2, 2), activation='relu', padding='same')(up9)
    up10 = Add()([up10, conv1])

    output = Conv2D(num_classes, (1, 1), activation='sigmoid')(up10)

    model = Model(inputs=inputs, outputs=output)
    return model

# 使用示例
input_shape = (256, 256, 3)
num_classes = 1
fcn_model = fcn_model(input_shape, num_classes)
fcn_model.summary()

from tensorflow.keras.optimizers import Adam

# 编译模型
fcn_model.compile(optimizer=Adam(learning_rate=1e-4),
              loss='binary_crossentropy',  # 对于二分类问题，可以使用 binary_crossentropy
              metrics=['accuracy'])

def load_data(image_dir, label_dir, target_size=(256, 256)):
    image_files = []
    label_files = []

    # Get the list of image files
    for file in os.listdir(image_dir):
        if file.endswith('.bmp'):
            image_files.append(os.path.join(image_dir, file))

    for file in os.listdir(label_dir):
        if file.endswith('.png'):
            label_files.append(os.path.join(label_dir, file))

    image_files = sorted(image_files)
    label_files = sorted(label_files)

    images = []
    labels = []

    # Load and preprocess image data
    for img_file, lbl_file in zip(image_files, label_files):
        img = Image.open(img_file).convert('RGB').resize(target_size)
        lbl = Image.open(lbl_file).convert('L').resize(target_size)

        img = np.array(img)
        lbl = np.array(lbl)
        lbl = np.expand_dims(lbl, axis=-1)  # Add channel dimension
        lbl[lbl > 0] = 1  # Binarize the label

        images.append(img)
        labels.append(lbl)

    images = np.array(images)
    labels = np.array(labels)

    return images, labels

#使用新的 load_data 函数，包括 target_size 参数
images, labels = load_data(image_dir, label_dir)
X_train, X_test, y_train, y_test = train_test_split(images, labels, test_size=0.1, random_state=42)

y_train = y_train.astype('float32')
y_test = y_test.astype('float32')

fcn_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# 训练模型
history = fcn_model.fit(X_train, y_train, batch_size=2, epochs=30, validation_split=0.1)

predictions_fcn = fcn_model.predict(X_test)
# Post-process and visualize predictions...

loss, accuracy = fcn_model.evaluate(X_test, y_test)
print(f"Test Loss: {loss}")
print(f"Test Accuracy: {accuracy}")

import matplotlib.pyplot as plt

# Plot training & validation loss values
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend(['Train', 'Validation'], loc='upper right')
plt.show()

# Plot training & validation accuracy values
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Model Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend(['Train', 'Validation'], loc='lower right')
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image, ImageEnhance

def print_plot(num_samples, X_test, y_test, predictions_fcn):
    for i in range(num_samples):
        plt.figure(figsize=(16, 8))

        # 显示原始图像
        plt.subplot(1, 4, 1)
        plt.imshow(X_test[i], cmap='gray', aspect='auto')
        plt.title('Original Image')
        plt.axis('off')

        # 显示真实的标签
        plt.subplot(1, 4, 2)
        plt.imshow(np.squeeze(y_test[i]), cmap='gray', aspect='auto')  # 使用np.squeeze()处理张量
        plt.title('True Label')
        plt.axis('off')

        # 显示模型的预测结果
        plt.subplot(1, 4, 3)
        plt.imshow(np.squeeze(predictions_fcn[i]), cmap='gray', aspect='auto')  # 使用np.squeeze()处理张量
        plt.title('Predicted Label')
        plt.axis('off')

        # 合并预测图像和增强，二值化并显示
        plt.subplot(1, 4, 4)
        threshold = 0.5
        pred_img_binary = np.where(np.squeeze(predictions_fcn[i]) > threshold, 0, 1)
        enhanced_pred_img = Image.fromarray(pred_img_binary.astype(np.uint8) * 255)
        contrast_enhancer = ImageEnhance.Contrast(enhanced_pred_img)
        enhanced_img = contrast_enhancer.enhance(1.0)
        plt.imshow(np.asarray(enhanced_img), cmap='binary', aspect='auto')
        plt.title('Enhanced Binary Predicted Label')
        plt.axis('off')

        plt.show()

# 在模型评估后调用可视化函数
num_samples = X_test.shape[0]  # 测试样本数量
print_plot(num_samples, X_test, y_test, predictions_fcn)











